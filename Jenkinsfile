// File : Jenkinsfile
// This Jenkinsfile uses a robust approach by running each build stage
// inside its own Docker container. This ensures a clean, consistent, and
// isolated environment for each part of the pipeline.

pipeline {
    agent any
    
    environment {
        // Define the application name and version for Docker image tagging.
        // This will be used to build and tag the Docker image.
        APP_NAME = 'jenkins-demo-app'
        APP_VERSION = "${BUILD_NUMBER}"
        DOCKER_IMAGE = "${APP_NAME}:${APP_VERSION}"
        
        // Telegram Bot Configuration
        // catatan : simpan token dan chat ID di Jenkins Credentials
        // -> gunakan credentials dengan tipe 'Secret text' untuk token dan 'Username with password'
        // -> pastikan nama credentials sesuai dengan yang digunakan di bawah ini
        // TELEGRAM_BOT_TOKEN = credentials('TG_TOKEN')    
        // TELEGRAM_CHAT_ID = credentials('TG_CHAT_ID')
        TELEGRAM_BOT_TOKEN = "XXX"    
        TELEGRAM_CHAT_ID = "XXX"
        
        // Catatan : apabila nama credentialsnya : TELEGRAM_BOT_TOKEN dan TELEGRAM_CHAT_ID, maka akan ada error
        // -> Telegram semacam mendeteksi dan langsung masking

        // Environment URLs
        STAGING_URL = 'http://localhost:8081'
        PRODUCTION_URL = 'http://localhost:8090'
        
        // Quality Gates
        TEST_THRESHOLD = '80'
        COVERAGE_THRESHOLD = '70'

        // Git Repository URL & // Branch Name
        GIT_REPO_URL_OPS = 'https://github.com/qanitasyaf/ops-secure-onboarding-system.git'
        BRANCH_NAME_OPS = 'master'

        GIT_REPO_URL_BE = 'https://github.com/bostang/backend-secure-onboarding-system.git'
        BRANCH_NAME_BE = 'deploy/gke'

        GIT_REPO_URL_FE = 'https://github.com/alvarolt17/frontend-secure-onboarding-system.git'
        BRANCH_NAME_FE = 'deploy/gke'

    }
    
    parameters {
        choice(
            name: 'DEPLOY_ENVIRONMENT',
            choices: ['staging', 'production', 'both'],
            description: 'Select deployment environment'
        )
        booleanParam(
            name: 'SKIP_TESTS',
            defaultValue: false,
            description: 'Skip test execution'
        )
        booleanParam(
            name: 'ENABLE_NOTIFICATIONS',
            defaultValue: false,
            description: 'Enable Telegram notifications'
        )
        string(
            name: 'CUSTOM_TAG',
            defaultValue: '',
            description: 'Custom Docker tag (optional)'
        )
    }
    
    stages {
        stage('üöÄ Pipeline Initialization') {
            steps {
                script {
                    // Calculate custom image tag
                    env.FINAL_TAG = params.CUSTOM_TAG ?: env.APP_VERSION
                    env.DOCKER_IMAGE_FINAL = "${APP_NAME}:${env.FINAL_TAG}"
                    
                    // Send detailed start notification
                    def startMessage = getStartMessage()
                    
                    if (params.ENABLE_NOTIFICATIONS) {
                        sendTelegramMessage(startMessage)
                    }
                }
                
                echo 'üîç Initializing pipeline...'
                echo "Deploy Environment: ${params.DEPLOY_ENVIRONMENT}"
                echo "Skip Tests: ${params.SKIP_TESTS}"
                echo "Docker Image: ${env.DOCKER_IMAGE_FINAL}"
            }
        }
        
        // ‚úÖ SUKSES (2025-08-03 09:16)
        stage('üì• Source Code Checkout') {
            steps {
                echo 'üì• Checking out source code...'
                
                script {
                    // Checkout repositori Ops
                    echo "--- Checking out Ops repository ---"
                    dir('ops-repo') { // Membuat direktori 'ops-repo' untuk repositori ini
                        checkout([
                            $class: 'GitSCM',
                            branches: [[name: "refs/heads/${env.BRANCH_NAME_OPS}"]],
                            userRemoteConfigs: [[url: env.GIT_REPO_URL_OPS]]
                        ])
                    }
                    
                    // Checkout repositori Backend
                    echo "--- Checking out Backend repository ---"
                    dir('backend-repo') { // Membuat direktori 'backend-repo'
                        checkout([
                            $class: 'GitSCM',
                            branches: [[name: "refs/heads/${env.BRANCH_NAME_BE}"]],
                            userRemoteConfigs: [[url: env.GIT_REPO_URL_BE]]
                        ])
                    }
                    
                    // Checkout repositori Frontend
                    echo "--- Checking out Frontend repository ---"
                    dir('frontend-repo') { // Membuat direktori 'frontend-repo'
                        checkout([
                            $class: 'GitSCM',
                            branches: [[name: "refs/heads/${env.BRANCH_NAME_FE}"]],
                            userRemoteConfigs: [[url: env.GIT_REPO_URL_FE]]
                        ])
                    }

                    // Dapatkan informasi commit dari salah satu repo (misal: backend)
                    // Langkah ini opsional, tapi berguna untuk notifikasi
                    def beCommit = sh(script: "cd backend-repo && git log -1 --pretty=format:'%h'", returnStdout: true).trim()
                    def beMessage = sh(script: "cd backend-repo && git log -1 --pretty=format:'%s'", returnStdout: true).trim()
                    
                    env.GIT_COMMIT_SHORT_BE = beCommit
                    env.GIT_COMMIT_MSG_BE = beMessage

                    if (params.ENABLE_NOTIFICATIONS) {
                        sendTelegramMessage("üì• <b>Checkout Complete</b>\nüîó **BE Commit:** ${env.GIT_COMMIT_SHORT_BE}\nüí¨ *${env.GIT_COMMIT_MSG_BE}*")
                    }
                }
                
                echo '‚úÖ Source code checkout completed'
                echo '--- Direktori Kerja ---'
                sh 'ls -la'
            }
        }
        
        // jangan lupa untu menginstall JDK 21 di Jenkins Global Tool Configuration
        // dan pastikan nama JDK sesuai dengan yang digunakan di bawah ini
        // -> misal: jdk21
        stage('üî® Build Application') {
            steps {
                script {
                    // Build Backend Application (Java Spring Boot)
                    echo 'üî® Building backend application...'
                    
                    dir('backend-repo') {
                        // Pastikan versi JDK yang sesuai tersedia.
                        // Anda bisa menggunakan 'tool' untuk memilih versi JDK yang sudah dikonfigurasi di Jenkins.
                        // Di sini, kita akan menggunakan 'withEnv' untuk memastikan 'JAVA_HOME' mengarah ke JDK 21.
                        // Jika JDK 21 sudah disiapkan di Jenkins Global Tool Configuration dengan nama 'jdk21',
                        // Anda bisa menggantinya dengan: withEnv(["JAVA_HOME=${tool 'jdk21'}"])
                        withEnv(["JAVA_HOME=${tool 'jdk21'}"]) {
                            sh 'mvn clean package -DskipTests'
                        }
                        echo '‚úÖ Backend build completed successfully'
                    }

                    // Build Frontend Application (React / Vite.js)
                    echo 'üî® Building frontend application...'
                    
                    dir('frontend-repo') {
                        withEnv(["PATH+NODE=${tool 'node18'}/bin"]) {
                            sh 'npm install' // Instal dependensi
                            sh 'npm run build' // Jalankan perintah build Vite.js
                            echo '‚úÖ Frontend build completed successfully'
                        }
                    }
                }
                
                // Kirim notifikasi setelah semua proses build selesai
                script {
                    if (params.ENABLE_NOTIFICATIONS) {
                        sendTelegramMessage("üî® <b>Build Stage Completed</b>\n‚úÖ Backend and frontend compiled successfully")
                    }
                }
            }
            
            // Blok `post` yang sudah ada cukup baik untuk menangani kegagalan.
            post {
                failure {
                    script {
                        if (params.ENABLE_NOTIFICATIONS) {
                            sendTelegramMessage("‚ùå <b>Build Failed</b>\nüö® Compilation errors detected")
                        }
                    }
                }
            }
        }
        
        stage('üß™ Testing & Quality Analysis') {
            parallel {
                stage('Unit Tests') {
                    when {
                        expression { !params.SKIP_TESTS }
                    }
                    steps {
                        echo 'üß™ Running unit tests...'
                        echo 'mvn test -B'
                        echo '‚úÖ All unit tests passed successfully'
                        
                        // Echo mock test results directory and files creation
                        echo 'mkdir -p target/surefire-reports'
                        echo 'echo "Mock test results" > target/surefire-reports/TEST-sample.xml'
                        echo 'üß™ Mock test results created in target/surefire-reports'
                    }
                    post {
                        always {
                            echo 'üß™ Publishing test results: target/surefire-reports/*.xml (simulated)'
                            echo 'üß™ Archiving test artifacts: target/surefire-reports/* (simulated)'
                        }
                        success {
                            script {
                                if (params.ENABLE_NOTIFICATIONS) {
                                    sendTelegramMessage("üß™ <b>Unit Tests Passed</b>\n‚úÖ All tests successful")
                                }
                            }
                        }
                        failure {
                            script {
                                if (params.ENABLE_NOTIFICATIONS) {
                                    sendTelegramMessage("‚ùå <b>Unit Tests Failed</b>\nüö® Test failures detected")
                                }
                            }
                        }
                    }
                }
                
                stage('Code Quality') {
                    steps {
                        echo 'üìä Running code quality analysis...'
                        echo 'mvn verify -B -DskipTests'
                        echo '‚úÖ Code quality analysis passed'
                        
                        script {
                            if (params.ENABLE_NOTIFICATIONS) {
                                sendTelegramMessage("üìä <b>Code Quality Check</b>\n‚úÖ Quality analysis completed")
                            }
                        }
                    }
                }
                
                stage('Security Scan') {
                    steps {
                        echo 'üîí Running security scan...'
                        script {
                            // Echo simulate security scan
                            echo 'sleep(time: 5, unit: SECONDS) - Security scan simulation'
                            echo 'Security scan completed - No vulnerabilities found'
                            
                            if (params.ENABLE_NOTIFICATIONS) {
                                sendTelegramMessage("üîí <b>Security Scan</b>\n‚úÖ No vulnerabilities detected")
                            }
                        }
                    }
                }
            }
        }
        
        stage('üì¶ Package Application') {
            steps {
                echo 'üì¶ Packaging the application...'
                echo 'mvn package -DskipTests -B'
                echo '‚úÖ JAR file created successfully'
                
                // Echo mock JAR file creation
                echo 'mkdir -p target'
                echo 'echo "Mock JAR content" > target/demo-app.jar'
                echo 'üì¶ Mock JAR file created in target directory'
                
                script {
                    if (params.ENABLE_NOTIFICATIONS) {
                        sendTelegramMessage("üì¶ <b>Package Complete</b>\n‚úÖ JAR file created successfully")
                    }
                }
            }
            post {
                success {
                    echo 'üì¶ Archiving artifacts: target/*.jar (simulated)'
                }
            }
        }
        
        stage('üê≥ Docker Build & Registry') {
            steps {
                echo 'üê≥ Building Docker image...'
                script {
                    echo "docker.build(\"${env.DOCKER_IMAGE_FINAL}\", \"-f docker/Dockerfile .\")"
                    echo "‚úÖ Docker image built: ${env.DOCKER_IMAGE_FINAL}"
                    
                    if (params.ENABLE_NOTIFICATIONS) {
                        sendTelegramMessage("üê≥ <b>Docker Image Built</b>\nüè∑Ô∏è Image: ${env.DOCKER_IMAGE_FINAL}")
                    }
                }
            }
        }
        
        stage('üéØ Staging Deployment') {
            when {
                anyOf {
                    equals expected: 'staging', actual: params.DEPLOY_ENVIRONMENT
                    equals expected: 'both', actual: params.DEPLOY_ENVIRONMENT
                }
            }
            steps {
                echo 'üéØ Deploying to staging environment...'
                script {
                    deployToEnvironment('staging', 8081, env.DOCKER_IMAGE_FINAL)
                    
                    if (params.ENABLE_NOTIFICATIONS) {
                        sendTelegramMessage("üéØ <b>Staging Deployment</b>\n‚úÖ Deployed successfully\nüîó URL: ${env.STAGING_URL}")
                    }
                }
            }
        }
        
        stage('üîç Staging Tests') {
            when {
                anyOf {
                    equals expected: 'staging', actual: params.DEPLOY_ENVIRONMENT
                    equals expected: 'both', actual: params.DEPLOY_ENVIRONMENT
                }
            }
            steps {
                echo 'üîç Running staging integration tests...'
                script {
                    echo 'Waiting for application to start...'
                    echo 'sleep(time: 10, unit: SECONDS) - Application startup simulation'
                    
                    // Mock health check
                    echo "curl -s -o /dev/null -w '%{http_code}' ${env.STAGING_URL}/health"
                    def healthStatus = '200'
                    echo "Health check status: ${healthStatus}"
                    
                    if (healthStatus == '200') {
                        echo '‚úÖ Health check passed'
                        
                        // Mock API test
                        echo "curl -f ${env.STAGING_URL}/"
                        echo '‚úÖ API test passed'
                        
                        if (params.ENABLE_NOTIFICATIONS) {
                            sendTelegramMessage("üîç <b>Staging Tests</b>\n‚úÖ All integration tests passed\nü©∫ Health: OK")
                        }
                    } else {
                        echo "‚ùå Staging health check failed with status: ${healthStatus} (simulated)"
                        echo "‚ö†Ô∏è In real scenario, this would cause pipeline failure"
                    }
                }
            }
            post {
                failure {
                    script {
                        if (params.ENABLE_NOTIFICATIONS) {
                            sendTelegramMessage("‚ùå <b>Staging Tests Failed</b>\nüö® Integration tests failed")
                        }
                    }
                }
            }
        }
        
        stage('‚è≥ QA Approval') {
            when {
                anyOf {
                    equals expected: 'production', actual: params.DEPLOY_ENVIRONMENT
                    equals expected: 'both', actual: params.DEPLOY_ENVIRONMENT
                }
            }
            steps {
                script {
                    if (params.ENABLE_NOTIFICATIONS) {
                        sendTelegramMessage("‚è≥ <b>QA Approval Required</b>\nüîç Please review staging environment\nüéØ Staging: ${env.STAGING_URL}\n‚è∞ Waiting for approval...")
                    }
                    
                    echo '‚è≥ QA Approval step - Auto-approving for demo'
                    echo 'QA Decision: Approve'
                    echo 'QA Comments: Auto-approved for pipeline demo'
                    
                    // Mock the approval variables
                    env.QA_DECISION = 'Approve'
                    env.QA_COMMENTS = 'Auto-approved for pipeline demo'
                    
                    if (params.ENABLE_NOTIFICATIONS) {
                        sendTelegramMessage("‚úÖ <b>QA Approved</b>\nüë§ Decision: ${env.QA_DECISION}\nüí¨ Comments: ${env.QA_COMMENTS}")
                    }
                }
            }
        }
        
        stage('üöÄ Production Deployment') {
            when {
                anyOf {
                    equals expected: 'production', actual: params.DEPLOY_ENVIRONMENT
                    equals expected: 'both', actual: params.DEPLOY_ENVIRONMENT
                }
            }
            steps {
                script {
                    if (params.ENABLE_NOTIFICATIONS) {
                        sendTelegramMessage("‚è≥ <b>DevOps Approval Required</b>\nüöÄ Ready for production deployment\n‚è∞ Waiting for final approval...")
                    }
                    
                    echo 'üöÄ DevOps Approval step - Auto-approving for demo'
                    echo 'DevOps Decision: Deploy'
                    echo 'Deployment Notes: Auto-approved for pipeline demo'
                    
                    // Mock the approval variables
                    env.DEVOPS_DECISION = 'Deploy'
                    env.DEPLOYMENT_NOTES = 'Auto-approved for pipeline demo'
                    
                    echo 'üöÄ Deploying to production environment...'
                    deployToEnvironment('prod', 8090, env.DOCKER_IMAGE_FINAL)
                    
                    if (params.ENABLE_NOTIFICATIONS) {
                        sendTelegramMessage("üöÄ <b>Production Deployment</b>\n‚úÖ Deployed successfully\nüë§ Approved by: DevOps\nüí¨ Notes: ${env.DEPLOYMENT_NOTES}\nüîó URL: ${env.PRODUCTION_URL}")
                    }
                }
            }
        }
        
        stage('üîç Production Verification') {
            when {
                anyOf {
                    equals expected: 'production', actual: params.DEPLOY_ENVIRONMENT
                    equals expected: 'both', actual: params.DEPLOY_ENVIRONMENT
                }
            }
            steps {
                echo 'üîç Verifying production deployment...'
                script {
                    echo 'Waiting for production application to start...'
                    echo 'sleep(time: 10, unit: SECONDS) - Production startup simulation'
                    
                    // Mock health check
                    echo "curl -s -o /dev/null -w '%{http_code}' ${env.PRODUCTION_URL}/health"
                    def healthStatus = '200'
                    echo "Production health check status: ${healthStatus}"
                    
                    if (healthStatus == '200') {
                        echo '‚úÖ Production health check passed'
                        
                        // Mock smoke test
                        echo "curl -f ${env.PRODUCTION_URL}/"
                        echo '‚úÖ Production smoke test passed'
                        
                        if (params.ENABLE_NOTIFICATIONS) {
                            sendTelegramMessage("üîç <b>Production Verification</b>\n‚úÖ All production tests passed\nü©∫ Health: OK\nüéâ Deployment successful!")
                        }
                    } else {
                        echo "‚ùå Production health check failed with status: ${healthStatus} (simulated)"
                        echo "‚ö†Ô∏è In real scenario, this would cause pipeline failure"
                    }
                }
            }
        }
        
        stage('üìä Post-Deployment Report') {
            steps {
                script {
                    def endTime = new Date().format('yyyy-MM-dd HH:mm:ss')
                    def duration = currentBuild.durationString.replace(' and counting', '')
                    
                    def reportMessage = getPostDeploymentReport(endTime, duration)
                    
                    if (params.ENABLE_NOTIFICATIONS) {
                        sendTelegramMessage(reportMessage)
                    }
                    
                    echo 'üìä Post-deployment report generated successfully'
                }
            }
        }
    }
    
    post {
        always {
            echo 'üßπ Cleaning up workspace...'
            // Echo instead of actual cleanup
            echo 'cleanWs()'
        }
        
        success {
            script {
                def successMessage = getPipelineSuccessMessage()
                
                if (params.ENABLE_NOTIFICATIONS) {
                    sendTelegramMessage(successMessage)
                }
            }
        }
        
        failure {
            script {
                def failureMessage = getPipelineFailureMessage()
                
                if (params.ENABLE_NOTIFICATIONS) {
                    sendTelegramMessage(failureMessage)
                }
            }
        }
        
        unstable {
            script {
                def unstableMessage = getPipelineUnstableMessage()
                
                if (params.ENABLE_NOTIFICATIONS) {
                    sendTelegramMessage(unstableMessage)
                }
            }
        }
        
        aborted {
            script {
                def abortedMessage = getAbortedMessage()
                
                if (params.ENABLE_NOTIFICATIONS) {
                    sendTelegramMessage(abortedMessage)
                }
            }
        }
    }
}

// Helper function to deploy to different environments
def deployToEnvironment(String environment, int port, String dockerImage) {
    echo "Deploying to ${environment} on port ${port}"
    
    // Echo instead of actual Docker commands
    echo "docker stop ${env.APP_NAME}-${environment} || true"
    echo "docker rm ${env.APP_NAME}-${environment} || true"
    
    // Echo Docker run command
    echo """docker run -d \\
        --name ${env.APP_NAME}-${environment} \\
        -p ${port}:8080 \\
        -e SPRING_PROFILES_ACTIVE=${environment} \\
        --restart unless-stopped \\
        ${dockerImage}"""
    
    echo "‚úÖ ${environment} deployment completed"
}

// Enhanced Telegram notification function with retry logic
def sendTelegramMessage(String message) {
    if (!params.ENABLE_NOTIFICATIONS) {
        return
    }
    
    try {
        echo "üì± Sending Telegram notification:"
        echo "Message: ${message}"
        echo "‚úÖ Telegram notification sent successfully (simulated)"
    } catch (Exception e) {
        echo "‚ùå Telegram notification error: ${e.getMessage()}"
    }

    try {
        def encodedMessage = message.replaceAll('"', '\\\\"')
        def maxRetries = 3
        def retryCount = 0
        def success = false
    
        while (retryCount < maxRetries && !success) {
            try {
                def response = sh(
                    script: """
                        curl -s -X POST https://api.telegram.org/bot\${TELEGRAM_BOT_TOKEN}/sendMessage \
                            -d chat_id=\${TELEGRAM_CHAT_ID} \
                            -d text="${encodedMessage}" \
                            -d parse_mode=HTML \
                            -w "HTTP_CODE:%{http_code}"
                    """,
                    returnStdout: true
                ).trim()
                
                if (response.contains('HTTP_CODE:200')) {
                    echo "‚úÖ Telegram notification sent successfully"
                    success = true
                } else {
                    throw new Exception("HTTP error: ${response}")
                }
            } catch (Exception e) {
                retryCount++
                echo "‚ö†Ô∏è Telegram notification attempt ${retryCount} failed: ${e.getMessage()}"
                if (retryCount < maxRetries) {
                    sleep(time: 5, unit: 'SECONDS')
                }
            }
        }
        
        if (!success) {
            echo "‚ùå Failed to send Telegram notification after ${maxRetries} attempts"
        }
    } catch (Exception e) {
        echo "‚ùå Telegram notification error: ${e.getMessage()}"
    }
}

// Helper functions for messages
def getStartMessage() {
    return """
    üöÄ <b>CI/CD Pipeline Started</b>
    ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
    üìã <b>Job:</b> ${env.JOB_NAME}
    üî¢ <b>Build:</b> #${env.BUILD_NUMBER}
    üåø <b>Branch:</b> ${env.BRANCH_NAME ?: 'main'}
    üéØ <b>Environment:</b> ${params.DEPLOY_ENVIRONMENT}
    üè∑Ô∏è <b>Tag:</b> ${env.FINAL_TAG}
    üë§ <b>Triggered by:</b> ${env.BUILD_USER ?: 'System'}
    ‚è∞ <b>Started at:</b> ${new Date().format('yyyy-MM-dd HH:mm:ss')}
    üîó <b>Console:</b> ${env.BUILD_URL}console
    """
}

def getPostDeploymentReport(String endTime, String duration) {
    return """
    üìä <b>Post-Deployment Report</b>
    ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
    ‚úÖ <b>Status:</b> SUCCESS
    üìã <b>Job:</b> ${env.JOB_NAME}
    üî¢ <b>Build:</b> #${env.BUILD_NUMBER}
    üè∑Ô∏è <b>Version:</b> ${env.FINAL_TAG}
    üéØ <b>Environment:</b> ${params.DEPLOY_ENVIRONMENT}
    ‚è±Ô∏è <b>Duration:</b> ${duration}
    ‚è∞ <b>Completed:</b> ${endTime}

    üåê <b>Deployed URLs:</b>
    ${params.DEPLOY_ENVIRONMENT.contains('staging') ? 'üéØ Staging: ' + env.STAGING_URL : ''}
    ${params.DEPLOY_ENVIRONMENT.contains('production') ? 'üöÄ Production: ' + env.PRODUCTION_URL : ''}

    üîó <b>Jenkins:</b> ${env.BUILD_URL}
    """
}

def getPipelineSuccessMessage() {
    return """üéâ <b>Pipeline Completed Successfully!</b>
    ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
    ‚úÖ <b>Result:</b> SUCCESS
    üìã <b>Job:</b> ${env.JOB_NAME}
    üî¢ <b>Build:</b> #${env.BUILD_NUMBER}
    ‚è±Ô∏è <b>Duration:</b> ${currentBuild.durationString.replace(' and counting', '')}
    üéØ <b>Environment:</b> ${params.DEPLOY_ENVIRONMENT}
    """
}

def getPipelineFailureMessage() {
    return """
    ‚ùå <b>Pipeline Failed!</b>
    ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
    üö® <b>Result:</b> FAILURE
    üìã <b>Job:</b> ${env.JOB_NAME}
    üî¢ <b>Build:</b> #${env.BUILD_NUMBER}
    ‚è±Ô∏è <b>Duration:</b> ${currentBuild.durationString.replace(' and counting', '')}
    üîó <b>Console:</b> ${env.BUILD_URL}console
    """
}

def getPipelineUnstableMessage() {
    return """
    ‚ö†Ô∏è <b>Pipeline Unstable</b>
    ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
    üü° <b>Result:</b> UNSTABLE
    üìã <b>Job:</b> ${env.JOB_NAME}
    üî¢ <b>Build:</b> #${env.BUILD_NUMBER}
    üîó <b>Console:</b> ${env.BUILD_URL}console
    """
}

def getAbortedMessage() {
    return """
    üõë <b>Pipeline Aborted</b>
    ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
    üî¥ <b>Result:</b> ABORTED
    üìã <b>Job:</b> ${env.JOB_NAME}
    üî¢ <b>Build:</b> #${env.BUILD_NUMBER}
    """
}